#include "../../defines.h"
#include "bankEditor.h"

namespace UI::MED {
    editableMap::editableMap( model& p_model ) {
        _model = p_model;

        _mainWindow = Gtk::ScrolledWindow( );
        _mainWindow.set_child( _mapGrid );
        _mapGrid.set_halign( Gtk::Align::CENTER );
        _mapGrid.set_valign( Gtk::Align::CENTER );

        for( u8 x = 0; x < 3; ++x ) {
            _model.m_settings.m_currentMap.push_back( std::vector<lookupMapSlice>( 3 ) );
            for( u8 y = 0; y < 3; ++y ) {
                _mapGrid.attach( _model.m_settings.m_currentMap[ x ][ y ], x, y );
                _model.m_settings.m_currentMap[ x ][ y ].connectClick(
                    [ this, x, y ]( UI::mapSlice::clickType p_button, u16 p_blockX, u16 p_blockY ) {
                        onMapClicked( p_button, p_blockX, p_blockY, s8( x ) - 1, s8( y ) - 1,
                                      x == 1 && y == 1 );
                    } );
                _model.m_settings.m_currentMap[ x ][ y ].connectDrag(
                    [ this, x, y ]( UI::mapSlice::clickType p_button, u16 p_blockX, u16 p_blockY ) {
                        onMapDragStart( p_button, p_blockX, p_blockY, s8( x ) - 1, s8( y ) - 1,
                                        x == 1 && y == 1 );
                    },
                    [ this, x, y ]( UI::mapSlice::clickType p_button, u16 p_blockX, u16 p_blockY ) {
                        onMapDragUpdate( p_button, p_blockX, p_blockY, s8( x ) - 1, s8( y ) - 1,
                                         x == 1 && y == 1 );
                    },
                    [ this, x, y ]( UI::mapSlice::clickType p_button, u16 p_blockX, u16 p_blockY ) {
                        onMapDragEnd( p_button, p_blockX, p_blockY, s8( x ) - 1, s8( y ) - 1,
                                      x == 1 && y == 1 );
                    } );
            }
        }

        _mapGrid.set_row_spacing( _neighborSpacing );
        _mapGrid.set_column_spacing( _neighborSpacing );

        _mainWindow.set_expand( );

        _blockStamp = std::make_shared<blockStamp>( );
    }

    void editableMap::setNewMapEditMode( mapEditor::mapDisplayMode p_newMode ) {
        // TODO
        _currentMapDisplayMode = p_newMode;
    }

    void editableMap::updateSelectedBlock( DATA::mapBlockAtom p_block ) {
        _model.m_settings.m_currentlySelectedBlock = p_block;
    }

    void editableMap::onMapDragStart( UI::mapSlice::clickType p_button, u16 p_blockX, u16 p_blockY,
                                      s8 p_mapX, s8 p_mapY, bool ) {
        _dragStart = { p_blockX, p_blockY, p_mapX, p_mapY };
        _dragLast  = { p_blockX, p_blockY };
        if( p_button == mapSlice::clickType::RIGHT ) {
            // reset blockStamp
            if( _blockStamp ) { _blockStamp->reset( ); }
        }
    }

    void root::onMapDragUpdate( UI::mapSlice::clickType p_button, s16 p_dX, s16 p_dY, s8 p_mapX,
                                s8 p_mapY, bool p_allowEdit ) {

        auto [ sx, sy, _1, _2 ] = _dragStart;
        auto [ lx, ly ]         = _dragLast;
        (void) _1;
        (void) _2;

        auto blockwd = _blockScale * DATA::BLOCK_SIZE + _blockSpacing;
        auto nx      = sx + ( p_dX / blockwd );
        auto ny      = sy + ( p_dY / blockwd );

        if( nx == lx && ny == ly ) { return; }
        _dragLast = { nx, ny };

        //        fprintf( stderr, "DragUpdate butto %hu bx: %hu by: %hu, %hhi %hhi %hhu\n",
        //        p_button, nx, ny,
        //                 p_mapX, p_mapY, p_allowEdit );

        if( p_allowEdit && p_button == mapSlice::clickType::LEFT
            && isInMapBounds( nx, ny, p_mapX, p_mapY ) ) {
            onMapClicked( p_button, nx, ny, p_mapX, p_mapY, p_allowEdit );
        }
        if( p_button == mapSlice::clickType::RIGHT ) {
            if( _currentMapDisplayMode == MODE_EDIT_TILES
                || _currentMapDisplayMode == MODE_EDIT_MOVEMENT ) {

                // update and show the stamp box

                if( _blockStamp ) { _blockStamp->create( ); }

                // Check if the stamp should go across map borders
                if( p_mapX == 1 ) {
                    if( nx < -DATA::SIZE - _model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    } else if( nx < -DATA::SIZE ) {
                        // crossing two borders
                        nx = sx + ( p_dX + 2 * _neighborSpacing + 2 * _blockSpacing ) / blockwd - 1;
                    } else if( nx < 0 ) {
                        // crossing one border
                        nx = sx + ( p_dX + _neighborSpacing + _blockSpacing ) / blockwd - 1;
                    } else if( nx >= _model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    }
                } else if( p_mapX == 0 ) {
                    if( nx < -_model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    } else if( nx < 0 ) {
                        // crossing one border
                        nx = sx + ( p_dX + _neighborSpacing + _blockSpacing ) / blockwd - 1;
                    } else if( nx >= DATA::SIZE ) {
                        // crossing one border
                        nx = sx + ( p_dX - _neighborSpacing + _blockSpacing ) / blockwd;
                    } else if( nx >= DATA::SIZE + _model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    }
                } else {
                    if( nx < 0 ) {
                        // out of bounds
                        return;
                    } else if( nx >= _model.m_settings.m_adjacentBlocks ) {
                        // crossing one border
                        nx = sx + ( p_dX - _neighborSpacing + _blockSpacing ) / blockwd;
                    } else if( nx >= DATA::SIZE + _model.m_settings.m_adjacentBlocks ) {
                        // crossing two borders
                        nx = sx + ( p_dX - 2 * _neighborSpacing + 2 * _blockSpacing ) / blockwd;
                    } else if( nx >= DATA::SIZE + 2 * _model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    }
                }
                if( p_mapY == 1 ) {
                    if( ny < -DATA::SIZE - _model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    } else if( ny < -DATA::SIZE ) {
                        // crossing two borders
                        ny = sy + ( p_dY + 2 * _neighborSpacing - 2 * _blockSpacing ) / blockwd - 1;
                    } else if( ny < 0 ) {
                        // crossing one border
                        ny = sy + ( p_dY + _neighborSpacing - _blockSpacing ) / blockwd - 1;
                    } else if( ny >= _model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    }
                } else if( p_mapY == 0 ) {
                    if( ny < -_model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    } else if( ny < 0 ) {
                        // crossing one border
                        ny = sy + ( p_dY + _neighborSpacing + _blockSpacing ) / blockwd - 1;
                    } else if( ny >= DATA::SIZE ) {
                        // crossing one border
                        ny = sy + ( p_dY - _neighborSpacing + _blockSpacing ) / blockwd;
                    } else if( ny >= DATA::SIZE + _model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    }
                } else {
                    if( ny < 0 ) {
                        // out of bounds
                        return;
                    } else if( ny >= _model.m_settings.m_adjacentBlocks ) {
                        // crossing one border
                        ny = sy + ( p_dY - _neighborSpacing + _blockSpacing ) / blockwd;
                    } else if( ny >= DATA::SIZE + _model.m_settings.m_adjacentBlocks ) {
                        // crossing two borders
                        ny = sy + ( p_dY - 2 * _neighborSpacing + 2 * _blockSpacing ) / blockwd;
                    } else if( ny >= DATA::SIZE + 2 * _model.m_settings.m_adjacentBlocks ) {
                        // out of bounds
                        return;
                    }
                }

                _dragLast = { nx, ny };
                if( nx == lx && ny == ly ) { return; }

                bool revx = nx < sx;
                bool revy = ny < sy;
                s16  posx = sx, posy = sy;

                auto tmpMap = std::deque<std::deque<DATA::mapBlockAtom>>( );

                while( 1 ) {
                    if( revy && posy < ny ) { break; }
                    if( !revy && posy > ny ) { break; }

                    // build a new row
                    auto row = std::deque<DATA::mapBlockAtom>( );
                    bswd     = 0;
                    posx     = sx;
                    while( 1 ) {
                        if( revx && posx < nx ) { break; }
                        if( !revx && posx > nx ) { break; }

                        s8  mx = p_mapX, my = p_mapY;
                        s16 remx = posx, remy = posy;

                        // compute block position

                        while( mx >= -1 && mx <= 1 && !isInMapBounds( remx, 0, mx, my ) ) {
                            if( mx == 1 ) {
                                if( remx < 0 ) {
                                    remx += DATA::SIZE;
                                    mx--;
                                } else [[unlikely]] {
                                    break;
                                }
                            } else if( mx == 0 ) {
                                if( remx < 0 ) {
                                    remx += _model.m_settings.m_adjacentBlocks;
                                    mx--;
                                } else {
                                    remx -= DATA::SIZE;
                                    mx++;
                                }
                            }
                        }
                        while( my >= -1 && my <= 1 && !isInMapBounds( 0, remy, mx, my ) ) {
                            if( my == 1 ) {
                                if( remy < 0 ) {
                                    remy += DATA::SIZE;
                                    my--;
                                } else [[unlikely]] {
                                    break;
                                }
                            } else if( my == 0 ) {
                                if( remy < 0 ) {
                                    remy += _model.m_settings.m_adjacentBlocks;
                                    my--;
                                } else {
                                    remy -= DATA::SIZE;
                                    my++;
                                }
                            } else {
                                if( remy < 0 ) [[unlikely]] {
                                    break;
                                } else {
                                    remy -= _model.m_settings.m_adjacentBlocks;
                                    my++;
                                }
                            }
                        }
                        // compute block

                        u16 xcorr = 0, ycorr = 0;
                        if( mx < 0 ) { xcorr = DATA::SIZE - _model.m_settings.m_adjacentBlocks; }
                        if( my < 0 ) { ycorr = DATA::SIZE - _model.m_settings.m_adjacentBlocks; }

                        DATA::mapBlockAtom currentBlock;
                        if( _sideBar->selectedMapY( ) + mx < 0 || _sideBar->selectedMapX( ) + my < 0
                            || _sideBar->selectedMapX( ) + mx > _sideBar->selectedSizeX( )
                            || _sideBar->selectedMapY( ) + my > _sideBar->selectedSizeY( ) ) {
                            // out of map bank bounds, add a blank block
                            currentBlock = { 0, 1 };
                        } else {
                            auto& mp     = _sideBar->slice( );
                            currentBlock = mp.m_data.m_blocks[ remy + ycorr ][ remx + xcorr ];
                        }

                        if( revx ) {
                            row.push_front( currentBlock );
                            posx--;
                        } else {
                            row.push_back( currentBlock );
                            posx++;
                        }
                        bswd++;
                    }

                    if( revy ) {
                        tmpMap.push_front( row );
                        posy--;
                    } else {
                        tmpMap.push_back( row );
                        posy++;
                    }
                }

                auto tmpData = std::vector<DATA::mapBlockAtom>( );
                for( auto row : tmpMap ) {
                    for( auto block : row ) { tmpData.push_back( block ); }
                }

                if( _blockStamp ) { _blockStamp->update( tmpData, bswd ); }
            }
        }
    }

    void root::onMapDragEnd( UI::mapSlice::clickType /* p_button */, s16 /* p_dX */, s16 /* p_dY */,
                             s8 /* p_mapX */, s8 /* p_mapY */, bool /* p_allowEdit */ ) {
    }

    void root::onMapClicked( UI::mapSlice::clickType p_button, u16 p_blockX, u16 p_blockY,
                             s8 p_mapX, s8 p_mapY, bool p_allowEdit ) {

        // fprintf( stderr, "onMapClicked butto %hu bx: %hu by: %hu, %hhi %hhi %hhu\n", p_button,
        //         p_blockX, p_blockY, p_mapX, p_mapY, p_allowEdit );

        // compute block
        u16 xcorr = 0, ycorr = 0;
        if( p_mapX < 0 ) { xcorr = DATA::SIZE - _model.m_settings.m_adjacentBlocks; }
        if( p_mapY < 0 ) { ycorr = DATA::SIZE - _model.m_settings.m_adjacentBlocks; }

        if( _sideBar->selectedMapY( ) + p_mapY < 0 || _sideBar->selectedMapX( ) + p_mapX < 0
            || _sideBar->selectedMapX( ) + p_mapX > _sideBar->selectedSizeX( )
            || _sideBar->selectedMapY( ) + p_mapY > _sideBar->selectedSizeY( ) ) {
            if( p_button == mapSlice::clickType::RIGHT ) { updateSelectedBlock( { 0, 1 } ); }
            return;
        }

        auto& mp = _sideBar->slice( _sideBar->selectedBank( ), _sideBar->selectedMapY( ) + p_mapY,
                                    _sideBar->selectedMapX( ) + p_mapX );
        auto& block = mp.m_data.m_blocks[ p_blockY + ycorr ][ p_blockX + xcorr ];

        switch( p_button ) {
        case mapSlice::clickType::LEFT:
            if( p_allowEdit ) {
                if( _currentMapDisplayMode == MODE_EDIT_TILES ) {
                    // check if there is a valid block stamp
                    if( !_blockStampDialogInvalid ) {
                        // paste the block stamp
                        auto bx = p_blockX + xcorr, by = p_blockY + ycorr, pos = 0;
                        for( size_t y = 0; y < _blockStampData.size( ) / _blockStampWidth; ++y ) {
                            for( size_t x = 0; x < _blockStampWidth; ++x, ++pos ) {
                                if( bx + x < DATA::SIZE && by + y < DATA::SIZE ) {
                                    mp.m_data.m_blocks[ by + y ][ bx + x ] = _blockStampData[ pos ];
                                    _model.m_settings.m_currentMap[ p_mapX + 1 ][ p_mapY + 1 ]
                                        .updateBlock( _blockStampData[ pos ], bx + x, by + y );
                                    _model.m_settings.m_currentMap[ p_mapX + 1 ][ p_mapY + 1 ]
                                        .updateBlockMovement( _blockStampData[ pos ].m_movedata,
                                                              bx + x, by + y );
                                }
                            }
                        }
                    } else {
                        block.m_blockidx = _model.m_settings.m_currentlySelectedBlock.m_blockidx;
                        _model.m_settings.m_currentMap[ p_mapX + 1 ][ p_mapY + 1 ].updateBlock(
                            _model.m_settings.m_currentlySelectedBlock, p_blockX, p_blockY );
                    }
                } else if( _currentMapDisplayMode == MODE_EDIT_MOVEMENT ) {
                    if( !_blockStampDialogInvalid ) {
                        // paste the block stamp
                        auto bx = p_blockX + xcorr, by = p_blockY + ycorr, pos = 0;
                        for( size_t y = 0; y < _blockStampData.size( ) / _blockStampWidth; ++y ) {
                            for( size_t x = 0; x < _blockStampWidth; ++x, ++pos ) {
                                if( bx + x < DATA::SIZE && by + y < DATA::SIZE ) {
                                    mp.m_data.m_blocks[ by + y ][ bx + x ].m_movedata
                                        = _blockStampData[ pos ].m_movedata;
                                    _model.m_settings.m_currentMap[ p_mapX + 1 ][ p_mapY + 1 ]
                                        .updateBlockMovement( _blockStampData[ pos ].m_movedata,
                                                              bx + x, by + y );
                                }
                            }
                        }
                    } else {
                        block.m_movedata = _model.m_settings.m_currentlySelectedBlock.m_movedata;
                        _model.m_settings.m_currentMap[ p_mapX + 1 ][ p_mapY + 1 ]
                            .updateBlockMovement( block.m_movedata, p_blockX, p_blockY );
                    }
                }
                _sideBar->markSelectedBankChanged( );
            } else {
                updateSelectedBlock( block );
            }
            break;
        case mapSlice::clickType::RIGHT:
            if( _currentMapDisplayMode == MODE_EDIT_TILES
                || _currentMapDisplayMode == MODE_EDIT_MOVEMENT ) {
                updateSelectedBlock( block );
            }
            break;
        case mapSlice::clickType::MIDDLE:
            if( p_allowEdit ) {
                DATA::mapBlockAtom oldb = block;
                // flood fill
                auto bqueue = std::queue<std::pair<s16, s16>>( );
                bqueue.push( { p_blockY, p_blockX } );
                while( !bqueue.empty( ) ) {
                    auto [ cy, cx ] = bqueue.front( );
                    bqueue.pop( );

                    if( cx < 0 || cx >= DATA::SIZE || cy < 0 || cy >= DATA::SIZE ) { continue; }

                    if( _currentMapDisplayMode == MODE_EDIT_TILES ) {
                        if( mp.m_data.m_blocks[ cy ][ cx ].m_blockidx != oldb.m_blockidx ) {
                            continue;
                        }
                        mp.m_data.m_blocks[ cy ][ cx ].m_blockidx
                            = _model.m_settings.m_currentlySelectedBlock.m_blockidx;
                        _model.m_settings.m_currentMap[ p_mapX + 1 ][ p_mapY + 1 ].updateBlock(
                            _model.m_settings.m_currentlySelectedBlock, p_blockX, p_blockY );
                    } else if( _currentMapDisplayMode == MODE_EDIT_MOVEMENT ) {
                        if( mp.m_data.m_blocks[ cy ][ cx ].m_movedata != oldb.m_movedata ) {
                            continue;
                        }
                        mp.m_data.m_blocks[ cy ][ cx ].m_movedata
                            = _model.m_settings.m_currentlySelectedBlock.m_movedata;
                        _model.m_settings.m_currentMap[ p_mapX + 1 ][ p_mapY + 1 ]
                            .updateBlockMovement( mp.m_data.m_blocks[ cy ][ cx ].m_movedata,
                                                  p_blockX, p_blockY );
                    }

                    for( s8 i = -1; i <= 1; ++i ) {
                        for( s8 j = -1; j <= 1; ++j ) { bqueue.push( { cy + i, cx + j } ); }
                    }
                }
                _sideBar->markSelectedBankChanged( );
                redrawMap( _sideBar->selectedMapY( ) + p_mapY, _sideBar->selectedMapX( ) + p_mapX );
            } else {
                updateSelectedBlock( block );
            }
            break;
        default: break;
        }
    }

} // namespace UI::MED
